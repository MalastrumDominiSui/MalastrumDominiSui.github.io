---
title:  "How efficient is your algorithm?"
image: "/assets/The Big O.png"
---
 
Other than the name of a fascinating Batman/Evangelion hybrid show on Cartoon Network, "Big O" is a important general concept in coding. Even coders who balk at the idea of Calculus should find a way to talk about this, because it could easily set you ahead in an interview.

Recently I have been watching some tech related videos, and one of them caught my eye: an interview with a software engineer at Google.  Feel free to watch: 

<iframe width="560" height="315" src="https://www.youtube.com/embed/XKu_SEDAykw" frameborder="0" allowfullscreen></iframe>

 To summarize: In the video The engineer is given a number (call it _x_), and needs to find whether two numbers in a sorted array of numbers (3, 4, ... , 10, 11) sum to be _x_. There is a point where the interviewee begins to list solutions and _relate_ them to __mathematical slope functions__: _linear, logarithmic, etc._ Using this knowledge he is able to determine whether his solution is a higher quality, or lower quality algorithm.

 Intuitively I realized I have some very basic awareness about the "speed/cost" at which an algorithm operates, but I wanted to know more about how to talk about this concept specifically, and with conviction like this engineer does. I hope to better equip anyone to do this with my article.

This concept I am loosely referring to as "speed" in programming is referred to as the __Order__ of a function.  The way we write this order is called __Big O__ notation. To be clear: you would get funny looks if you said "So.. my functions Big O notation would be..."  Rather Big O notation is the __way__ we write the __Order__ of a function.

#### Some quick math ...

So in math we have a very simple function, like <code>x = 4</code>

This is a constant function that always evaluates to 4, no matter what any other value is. It looks like:

![constant](/assets/constant.jpg){: .article_img }

In programming this constant would be like a program that always returns the same thing, no matter what the input is. In ruby we could say:

def constant(arr)
	return "blah"
end

It doesn't matter if the array is empty, or googolplex elements long, this function will always evaluate the return statement, and be done. We refer to this function as having _Order 1_ or __O(1)__.

The next function is __linear__: for example the equation <code>y = x</code>, or if you prefer <code>f(x) = x</code>

It looks like this:

![constant](/assets/linear.jpg){: .article_img }

A function with linear order is a function that grows equal in __computation time__ or __resource consumption__ in a linear fashion. For each additional input to the function will add the same amount of time and resource consumption to the function.

In Ruby, an example of this would be: <br>

{% highlight ruby %}
def stringToCat (strArr)
	strArr.map do |string|
		string = "cat"
	end
end
{%endhighlight%}

For each additional string added to <code>strArr</code>, the function would iterate one additional time, and take one additional amount of space.  Thus we say the function stringToCat is _Order N_ or _O(N)_ .





